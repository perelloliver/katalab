{
  "45cc576a-add3-4ebb-97e4-900d2a411a89": {
    "output_dir": "downloads/45cc576a-add3-4ebb-97e4-900d2a411a89",
    "company_info": {
      "roles": [
        {
          "title": "Senior Backend Engineer",
          "stack": [
            "Go",
            "Java",
            "C++",
            "PostgreSQL",
            "DynamoDB",
            "Kubernetes",
            "Docker",
            "AWS"
          ],
          "requirements": "5+ years of backend engineering experience. Strong proficiency in Go or Java/C++. Willingness to work primarily in Go. Deep understanding of distributed systems patterns (idempotency, distributed transactions, SAGAs). Expert knowledge of SQL (PostgreSQL) and NoSQL stores. Solid experience with Kubernetes, Docker, and AWS services. Passion for TDD, clean code, and automated testing.",
          "team": {
            "name": "Core Ledger Team",
            "products": null,
            "clients": null,
            "size": 5,
            "context": "The Core Ledger Team is the heart of Nebula Financial. They manage the systems of record that track every penny (and satoshi) of user funds. They are responsible for the consistency, durability, and availability of the financial ledger.",
            "tools_used": [
              "Go",
              "Node.js"
            ],
            "philosophy": [
              "precision",
              "resilience",
              "continuous improvement",
              "Ownership & Accountability",
              "Security & Consistency First",
              "Proactive Problem Solving",
              "Knowledge Sharing & Mentorship",
              "Data-Driven Decisions"
            ]
          }
        }
      ],
      "teams": [
        {
          "name": "Core Ledger Team",
          "products": null,
          "clients": null,
          "size": 5,
          "context": "The Core Ledger Team is the heart of Nebula Financial. They manage the systems of record that track every penny (and satoshi) of user funds. They are responsible for the consistency, durability, and availability of the financial ledger.",
          "tools_used": [
            "Go",
            "Node.js"
          ],
          "philosophy": [
            "precision",
            "resilience",
            "continuous improvement",
            "Ownership & Accountability",
            "Security & Consistency First",
            "Proactive Problem Solving",
            "Knowledge Sharing & Mentorship",
            "Data-Driven Decisions"
          ]
        }
      ],
      "clients": null,
      "products": [
        {
          "name": "Nebula Wallet",
          "type": "product",
          "description": "Our flagship mobile application that allows users to store, send, and swap both fiat and crypto assets with zero fees. It features built-in high-yield savings accounts powered by DeFi protocols, abstracted away behind a simple, banking-grade UI.",
          "resources": null
        },
        {
          "name": "Flux Exchange",
          "type": "product",
          "description": "Our institutional-grade matching engine for high-frequency trading. Flux handles over 50,000 transactions per second (TPS) and provides liquidity to our consumer wallet and B2B partners.",
          "resources": null
        }
      ],
      "philosophy": "\"You Build It, You Run It.\""
    },
    "plan": {
      "title": "Core Ledger Simulation - Nebula Financial",
      "description": "This kata simulates building a simplified component of Nebula Financial's Core Ledger system. It assesses a candidate's ability to design, implement, and test robust and consistent financial record-keeping logic. The tasks focus on data consistency, concurrency, and basic API design.",
      "tasks": [
        {
          "id": "task_1_account_creation",
          "name": "Account Creation API",
          "description": "Design and implement a basic API endpoint (in Go) for creating new user accounts. Each account should have a unique ID (UUID), associated user ID, and an initial balance of 0.  Consider error handling for invalid user IDs. Use PostgreSQL for persistence.",
          "files": [
            "account.go",
            "account_test.go",
            "database.go"
          ]
        },
        {
          "id": "task_2_deposit_funds",
          "name": "Deposit Funds API",
          "description": "Implement an API endpoint to deposit funds into an account. Ensure the deposit amount is positive. Update the account balance atomically in PostgreSQL to prevent race conditions. Use SQL transactions to guarantee ACID properties. Include unit tests.",
          "files": [
            "account.go",
            "account_test.go",
            "database.go"
          ]
        },
        {
          "id": "task_3_withdraw_funds",
          "name": "Withdraw Funds API",
          "description": "Implement an API endpoint to withdraw funds from an account. Ensure the account has sufficient balance. Implement a check to prevent negative balances. Update the account balance atomically using SQL transactions. Include comprehensive unit tests covering edge cases (e.g., withdrawing the exact balance, insufficient funds).",
          "files": [
            "account.go",
            "account_test.go",
            "database.go"
          ]
        },
        {
          "id": "task_4_transfer_funds",
          "name": "Transfer Funds API (Single Transaction)",
          "description": "Implement an API endpoint to transfer funds between two accounts. Ensure both accounts exist. Handle the case where either account has insufficient funds. Use a single SQL transaction to ensure that the transfer is atomic (either both debit and credit succeed or neither does). Implement appropriate locking mechanisms to prevent deadlocks (e.g., always lock accounts in the same order).",
          "files": [
            "account.go",
            "account_test.go",
            "database.go"
          ]
        },
        {
          "id": "task_5_idempotency",
          "name": "Idempotency for Transfer Funds",
          "description": "Enhance the Transfer Funds API to be idempotent.  Implement a mechanism to detect and handle duplicate transfer requests using a unique transfer ID provided by the client. Store transfer IDs in a separate table in PostgreSQL.  Ensure that processing the same transfer ID multiple times only results in a single transfer between accounts. Add thorough testing for idempotency, including simulating network errors.",
          "files": [
            "account.go",
            "account_test.go",
            "database.go",
            "transfer_log.go"
          ]
        }
      ]
    }
  },
  "602fd910-c06f-4206-9fa6-fa15baf4e419": {
    "output_dir": "downloads/602fd910-c06f-4206-9fa6-fa15baf4e419",
    "company_info": {
      "roles": [
        {
          "title": "Senior Backend Engineer",
          "stack": [
            "Go",
            "Java",
            "C++",
            "PostgreSQL",
            "DynamoDB",
            "Kubernetes",
            "Docker",
            "AWS"
          ],
          "requirements": "5+ years of backend engineering experience. Strong proficiency in Go or Java/C++. Willingness to work primarily in Go. Deep understanding of distributed systems patterns (idempotency, distributed transactions, SAGAs). Expert knowledge of SQL (PostgreSQL) and NoSQL stores. Solid experience with Kubernetes, Docker, and AWS services. Passion for TDD, clean code, and automated testing.",
          "team": {
            "name": "Core Ledger Team",
            "products": null,
            "clients": null,
            "size": 5,
            "context": "The Core Ledger Team is the heart of Nebula Financial. We manage the systems of record that track every penny (and satoshi) of user funds. We are responsible for the consistency, durability, and availability of the financial ledger.",
            "tools_used": [
              "Go",
              "Node.js"
            ],
            "philosophy": [
              "precision",
              "resilience",
              "continuous improvement",
              "Ownership & Accountability",
              "Security & Consistency First",
              "Proactive Problem Solving",
              "Knowledge Sharing & Mentorship",
              "Data-Driven Decisions"
            ]
          }
        }
      ],
      "teams": [
        {
          "name": "Core Ledger Team",
          "products": null,
          "clients": null,
          "size": 5,
          "context": "The Core Ledger Team is the heart of Nebula Financial. We manage the systems of record that track every penny (and satoshi) of user funds. We are responsible for the consistency, durability, and availability of the financial ledger.",
          "tools_used": [
            "Go",
            "Node.js"
          ],
          "philosophy": [
            "precision",
            "resilience",
            "continuous improvement",
            "Ownership & Accountability",
            "Security & Consistency First",
            "Proactive Problem Solving",
            "Knowledge Sharing & Mentorship",
            "Data-Driven Decisions"
          ]
        }
      ],
      "clients": null,
      "products": [
        {
          "name": "Nebula Wallet",
          "type": "product",
          "description": "Our flagship mobile application that allows users to store, send, and swap both fiat and crypto assets with zero fees. It features built-in high-yield savings accounts powered by DeFi protocols, abstracted away behind a simple, banking-grade UI.",
          "resources": null
        },
        {
          "name": "Flux Exchange",
          "type": "product",
          "description": "Our institutional-grade matching engine for high-frequency trading. Flux handles over 50,000 transactions per second (TPS) and provides liquidity to our consumer wallet and B2B partners.",
          "resources": null
        }
      ],
      "philosophy": "\"You Build It, You Run It.\""
    },
    "plan": {
      "title": "Core Ledger Transaction Processing Kata",
      "description": "This kata simulates building a simplified transaction processing system for Nebula Financial's Core Ledger. It assesses a candidate's ability to design, implement, and test robust and scalable backend services using Go, with a focus on data consistency, error handling, and distributed systems principles.",
      "tasks": [
        {
          "id": "task_1_data_model",
          "name": "Define Transaction Data Model",
          "description": "Define the data structure for a financial transaction. This should include fields like transaction ID, account ID, transaction type (deposit, withdrawal, transfer), amount, currency, timestamp, and status (pending, completed, failed). Consider using appropriate data types for each field to ensure accuracy and prevent common data-related errors. Create a corresponding Go struct.",
          "files": [
            "transaction.go"
          ]
        },
        {
          "id": "task_2_transaction_logging",
          "name": "Implement Transaction Logging",
          "description": "Implement a logging mechanism for tracking transactions. Utilize Go's built-in `log` package or a more sophisticated logging library like `logrus` or `zap`. Log key transaction details at different stages of processing (e.g., when a transaction is received, when it's successfully processed, when an error occurs). Include the ability to configure logging levels (debug, info, warning, error).",
          "files": [
            "logger.go",
            "transaction.go"
          ]
        },
        {
          "id": "task_3_idempotency_handling",
          "name": "Implement Idempotency Handling",
          "description": "Design and implement a mechanism to ensure idempotency of transaction processing. Use transaction ID or combination of other unique fields as key for idempotency check. If the transaction has already been processed, the system should return the previous result without re-executing the transaction logic. Consider using an in-memory store (for simplicity) or an external storage system (e.g., Redis) for tracking processed transactions. This ensures that duplicate transaction requests due to network issues or retries do not lead to incorrect ledger balances.",
          "files": [
            "transaction_processor.go",
            "transaction.go"
          ]
        },
        {
          "id": "task_4_basic_transaction_processing",
          "name": "Implement Basic Transaction Processing Logic",
          "description": "Implement the core logic for processing deposit, withdrawal, and transfer transactions. Simulate updating account balances in a simple in-memory map. Ensure that withdrawals do not result in negative balances (return an error if insufficient funds). Implement basic error handling and logging for failed transactions.",
          "files": [
            "transaction_processor.go",
            "account.go",
            "transaction.go"
          ]
        },
        {
          "id": "task_5_concurrent_transaction_handling",
          "name": "Implement Concurrent Transaction Handling",
          "description": "Modify the transaction processing logic to handle concurrent transactions safely. Use mutexes or channels to synchronize access to the account balances map and prevent race conditions. Design your solution to minimize contention and maximize throughput. Simulate multiple concurrent transaction requests to test your implementation.",
          "files": [
            "transaction_processor.go",
            "account.go",
            "transaction.go"
          ]
        },
        {
          "id": "task_6_testing_and_validation",
          "name": "Write Unit Tests and Validation",
          "description": "Write comprehensive unit tests to validate the transaction processing logic, idempotency handling, and concurrency control mechanisms. Cover various scenarios, including successful transactions, insufficient funds errors, duplicate transactions, and concurrent requests. Use table-driven tests to improve test coverage and maintainability.",
          "files": [
            "transaction_processor_test.go",
            "transaction.go",
            "account.go"
          ]
        }
      ]
    }
  },
  "fcb980cc-bcfe-4882-ba85-e02628268d0c": {
    "output_dir": "downloads/fcb980cc-bcfe-4882-ba85-e02628268d0c",
    "company_info": {
      "roles": [
        {
          "title": "Lead Engineer",
          "stack": [],
          "requirements": "Distributed systems, fierce code reviewer, system performance.",
          "team": {
            "name": "Core Ledger Team",
            "products": [],
            "clients": [],
            "size": 5,
            "context": "The Core Ledger Team is the heart of Nebula Financial. We manage the systems of record that track every penny (and satoshi) of user funds. We are responsible for the consistency, durability, and availability of the financial ledger.",
            "tools_used": [
              "Node.js",
              "Go",
              "PostgreSQL",
              "DynamoDB",
              "Kubernetes",
              "Docker",
              "AWS",
              "Datadog",
              "Prometheus",
              "Grafana"
            ],
            "philosophy": [
              "precision",
              "resilience",
              "continuous improvement",
              "Ownership & Accountability",
              "Security & Consistency First",
              "Proactive Problem Solving",
              "Knowledge Sharing & Mentorship",
              "Data-Driven Decisions"
            ]
          }
        },
        {
          "title": "Senior Engineer",
          "stack": [
            "Node.js"
          ],
          "requirements": "Deep domain knowledge of banking APIs (SEPA, Swift).",
          "team": {
            "name": "Core Ledger Team",
            "products": [],
            "clients": [],
            "size": 5,
            "context": "The Core Ledger Team is the heart of Nebula Financial. We manage the systems of record that track every penny (and satoshi) of user funds. We are responsible for the consistency, durability, and availability of the financial ledger.",
            "tools_used": [
              "Node.js",
              "Go",
              "PostgreSQL",
              "DynamoDB",
              "Kubernetes",
              "Docker",
              "AWS",
              "Datadog",
              "Prometheus",
              "Grafana"
            ],
            "philosophy": [
              "precision",
              "resilience",
              "continuous improvement",
              "Ownership & Accountability",
              "Security & Consistency First",
              "Proactive Problem Solving",
              "Knowledge Sharing & Mentorship",
              "Data-Driven Decisions"
            ]
          }
        },
        {
          "title": "Backend Engineer",
          "stack": [
            "Go"
          ],
          "requirements": "Strong Go developer, very productive.",
          "team": {
            "name": "Core Ledger Team",
            "products": [],
            "clients": [],
            "size": 5,
            "context": "The Core Ledger Team is the heart of Nebula Financial. We manage the systems of record that track every penny (and satoshi) of user funds. We are responsible for the consistency, durability, and availability of the financial ledger.",
            "tools_used": [
              "Node.js",
              "Go",
              "PostgreSQL",
              "DynamoDB",
              "Kubernetes",
              "Docker",
              "AWS",
              "Datadog",
              "Prometheus",
              "Grafana"
            ],
            "philosophy": [
              "precision",
              "resilience",
              "continuous improvement",
              "Ownership & Accountability",
              "Security & Consistency First",
              "Proactive Problem Solving",
              "Knowledge Sharing & Mentorship",
              "Data-Driven Decisions"
            ]
          }
        },
        {
          "title": "Junior Backend",
          "stack": [],
          "requirements": "Eager learner, great at frontend/internal tools.",
          "team": {
            "name": "Core Ledger Team",
            "products": [],
            "clients": [],
            "size": 5,
            "context": "The Core Ledger Team is the heart of Nebula Financial. We manage the systems of record that track every penny (and satoshi) of user funds. We are responsible for the consistency, durability, and availability of the financial ledger.",
            "tools_used": [
              "Node.js",
              "Go",
              "PostgreSQL",
              "DynamoDB",
              "Kubernetes",
              "Docker",
              "AWS",
              "Datadog",
              "Prometheus",
              "Grafana"
            ],
            "philosophy": [
              "precision",
              "resilience",
              "continuous improvement",
              "Ownership & Accountability",
              "Security & Consistency First",
              "Proactive Problem Solving",
              "Knowledge Sharing & Mentorship",
              "Data-Driven Decisions"
            ]
          }
        },
        {
          "title": "Senior Backend Engineer",
          "stack": [
            "Go",
            "Java",
            "C++",
            "PostgreSQL",
            "NoSQL",
            "Kubernetes",
            "Docker",
            "AWS"
          ],
          "requirements": "5+ years of backend engineering experience. Strong proficiency in Go or Java/C++. Willingness to work primarily in Go. Deep understanding of distributed systems patterns (idempotency, distributed transactions, SAGAs). Expert knowledge of SQL (PostgreSQL) and NoSQL stores. Solid experience with Kubernetes, Docker, and AWS services. Passion for TDD, clean code, and automated testing.",
          "team": {
            "name": "Core Ledger Team",
            "products": [],
            "clients": [],
            "size": 5,
            "context": "The Core Ledger Team is the heart of Nebula Financial. We manage the systems of record that track every penny (and satoshi) of user funds. We are responsible for the consistency, durability, and availability of the financial ledger.",
            "tools_used": [
              "Node.js",
              "Go",
              "PostgreSQL",
              "DynamoDB",
              "Kubernetes",
              "Docker",
              "AWS",
              "Datadog",
              "Prometheus",
              "Grafana"
            ],
            "philosophy": [
              "precision",
              "resilience",
              "continuous improvement",
              "Ownership & Accountability",
              "Security & Consistency First",
              "Proactive Problem Solving",
              "Knowledge Sharing & Mentorship",
              "Data-Driven Decisions"
            ]
          }
        }
      ],
      "teams": [
        {
          "name": "Core Ledger Team",
          "products": [],
          "clients": [],
          "size": 5,
          "context": "The Core Ledger Team is the heart of Nebula Financial. We manage the systems of record that track every penny (and satoshi) of user funds. We are responsible for the consistency, durability, and availability of the financial ledger.",
          "tools_used": [
            "Node.js",
            "Go",
            "PostgreSQL",
            "DynamoDB",
            "Kubernetes",
            "Docker",
            "AWS",
            "Datadog",
            "Prometheus",
            "Grafana"
          ],
          "philosophy": [
            "precision",
            "resilience",
            "continuous improvement",
            "Ownership & Accountability",
            "Security & Consistency First",
            "Proactive Problem Solving",
            "Knowledge Sharing & Mentorship",
            "Data-Driven Decisions"
          ]
        }
      ],
      "clients": [],
      "products": [
        {
          "name": "Nebula Wallet",
          "type": "product",
          "description": "Our flagship mobile application that allows users to store, send, and swap both fiat and crypto assets with zero fees. It features built-in high-yield savings accounts powered by DeFi protocols, abstracted away behind a simple, banking-grade UI.",
          "resources": []
        },
        {
          "name": "Flux Exchange",
          "type": "product",
          "description": "Our institutional-grade matching engine for high-frequency trading. Flux handles over 50,000 transactions per second (TPS) and provides liquidity to our consumer wallet and B2B partners.",
          "resources": []
        }
      ],
      "philosophy": "\"You Build It, You Run It.\""
    },
    "plan": {
      "title": "Nebula Financial Core Ledger Kata",
      "description": "This kata simulates building a simplified version of Nebula Financial's core ledger system, focusing on transaction processing, concurrency, and data consistency. It's designed to assess a candidate's ability to design and implement robust, high-performance backend systems using Go, with a focus on the principles of the Core Ledger Team.",
      "tasks": [
        {
          "id": "task_1_transaction_struct",
          "name": "Define Transaction Structure",
          "description": "Define a `Transaction` struct in `transaction.go` that includes fields for `ID` (UUID), `Timestamp` (Unix timestamp), `FromAccount`, `ToAccount`, `Amount`, and `Status` (enum: `Pending`, `Confirmed`, `Rejected`). Implement functions to generate new transaction IDs and record the timestamp. Use the `uuid` package for generating IDs and `time` package for timestamps.",
          "files": [
            "transaction.go"
          ]
        },
        {
          "id": "task_2_account_management",
          "name": "Implement Account Management",
          "description": "Create an `Account` struct in `account.go` with fields for `ID`, `Balance`, and `Lock` (mutex for concurrency control). Implement functions to `Credit` and `Debit` an account, ensuring thread safety using the mutex. Implement an `InsufficientFundsError` error to return when debiting would result in a negative balance.",
          "files": [
            "account.go"
          ]
        },
        {
          "id": "task_3_transaction_processing",
          "name": "Build Transaction Processor",
          "description": "Create a `TransactionProcessor` in `processor.go` with a method `ProcessTransaction` that takes a `Transaction` and two `Account` objects as input. This function should: 1. Acquire locks on both `FromAccount` and `ToAccount` in a consistent order to prevent deadlocks (e.g., always lock accounts in ascending ID order). 2. Debit the `FromAccount`. 3. Credit the `ToAccount`. 4. Update the `Transaction` status to `Confirmed` or `Rejected` based on the outcome. 5. Log the transaction details using a structured logger (e.g., `logrus` or `zap`). Handle `InsufficientFundsError` and any other potential errors gracefully. Ensure to release the locks.",
          "files": [
            "processor.go"
          ]
        },
        {
          "id": "task_4_concurrency_handling",
          "name": "Simulate Concurrent Transactions",
          "description": "In `main.go`, create multiple goroutines to simulate concurrent transactions. Create a set of accounts with initial balances. Generate a series of transactions with random `FromAccount`, `ToAccount`, and `Amount`. Use the `TransactionProcessor` to process these transactions concurrently. Implement mechanisms to wait for all goroutines to complete (e.g., `sync.WaitGroup`).",
          "files": [
            "main.go"
          ]
        },
        {
          "id": "task_5_logging_and_monitoring",
          "name": "Implement Logging and Monitoring",
          "description": "Integrate structured logging (e.g., `logrus` or `zap`) throughout the application to log important events, such as transaction processing, account updates, and errors.  Include transaction IDs and account IDs in log messages for traceability. Implement basic metrics using the `expvar` package to expose transaction processing statistics (e.g., number of transactions processed, number of errors).",
          "files": [
            "main.go"
          ]
        },
        {
          "id": "task_6_idempotency",
          "name": "Implement Idempotency",
          "description": "Modify the `TransactionProcessor` to ensure transactions are processed idempotently. Introduce a simple check (e.g., using a map or a small in-memory store) to verify if a transaction with a given ID has already been processed. If a transaction has already been processed, return the previous result without re-executing the transaction logic.",
          "files": [
            "processor.go"
          ]
        }
      ]
    }
  },
  "ed275991-47b9-4e51-bdf0-5629d84faa77": {
    "output_dir": "downloads/ed275991-47b9-4e51-bdf0-5629d84faa77",
    "company_info": {
      "roles": [
        {
          "title": "Senior Backend Engineer (Core Systems)",
          "stack": [
            "Go",
            "Java",
            "C++",
            "PostgreSQL",
            "DynamoDB",
            "Kubernetes",
            "Docker",
            "AWS",
            "Istio",
            "Linkerd",
            "Node.js"
          ],
          "requirements": "5+ years of backend engineering experience. Strong proficiency in Go or Java/C++ with a willingness to work primarily in Go. Deep understanding of distributed systems patterns (idempotency, distributed transactions, SAGAs). Expert knowledge of SQL (PostgreSQL) and NoSQL stores. Solid experience with Kubernetes, Docker, and AWS services. Passion for TDD, clean code, and automated testing.",
          "team": {
            "name": "Core Ledger Team",
            "products": [
              {
                "name": "Nebula Wallet",
                "type": "product",
                "description": "Flagship mobile application that allows users to store, send, and swap both fiat and crypto assets with zero fees. Features built-in high-yield savings accounts.",
                "resources": null
              },
              {
                "name": "Flux Exchange",
                "type": "product",
                "description": "Institutional-grade matching engine for high-frequency trading handling over 50,000 transactions per second.",
                "resources": null
              }
            ],
            "clients": null,
            "size": 5,
            "context": "The heart of Nebula Financial. Manages the systems of record that track every penny and satoshi of user funds. Responsible for the consistency, durability, and availability of the financial ledger. Currently stalled in a migration from a legacy Node.js monolith to a new Go distributed ledger.",
            "tools_used": [
              "Go",
              "Node.js",
              "PostgreSQL",
              "DynamoDB",
              "AWS",
              "Kubernetes",
              "EKS",
              "Terraform",
              "GitHub Actions",
              "Datadog",
              "Prometheus",
              "Grafana"
            ],
            "philosophy": [
              "You Build It, You Run It",
              "Precision, resilience, and continuous improvement",
              "Ownership & Accountability",
              "Security & Consistency First",
              "Proactive Problem Solving",
              "Knowledge Sharing & Mentorship",
              "Data-Driven Decisions",
              "Test-Driven Development (TDD)",
              "Immutable Infrastructure",
              "Defensive Programming",
              "High Pressure",
              "Direct Feedback",
              "Async First"
            ]
          }
        }
      ],
      "teams": [
        {
          "name": "Core Ledger Team",
          "products": [
            {
              "name": "Nebula Wallet",
              "type": "product",
              "description": "Flagship mobile application that allows users to store, send, and swap both fiat and crypto assets with zero fees. Features built-in high-yield savings accounts.",
              "resources": null
            },
            {
              "name": "Flux Exchange",
              "type": "product",
              "description": "Institutional-grade matching engine for high-frequency trading handling over 50,000 transactions per second.",
              "resources": null
            }
          ],
          "clients": null,
          "size": 5,
          "context": "The heart of Nebula Financial. Manages the systems of record that track every penny and satoshi of user funds. Responsible for the consistency, durability, and availability of the financial ledger. Currently stalled in a migration from a legacy Node.js monolith to a new Go distributed ledger.",
          "tools_used": [
            "Go",
            "Node.js",
            "PostgreSQL",
            "DynamoDB",
            "AWS",
            "Kubernetes",
            "EKS",
            "Terraform",
            "GitHub Actions",
            "Datadog",
            "Prometheus",
            "Grafana"
          ],
          "philosophy": [
            "You Build It, You Run It",
            "Precision, resilience, and continuous improvement",
            "Ownership & Accountability",
            "Security & Consistency First",
            "Proactive Problem Solving",
            "Knowledge Sharing & Mentorship",
            "Data-Driven Decisions",
            "Test-Driven Development (TDD)",
            "Immutable Infrastructure",
            "Defensive Programming",
            "High Pressure",
            "Direct Feedback",
            "Async First"
          ]
        }
      ],
      "clients": null,
      "products": [
        {
          "name": "Nebula Wallet",
          "type": "product",
          "description": "Flagship mobile application that allows users to store, send, and swap both fiat and crypto assets with zero fees. Features built-in high-yield savings accounts powered by DeFi protocols.",
          "resources": null
        },
        {
          "name": "Flux Exchange",
          "type": "product",
          "description": "Institutional-grade matching engine for high-frequency trading. Handles over 50,000 transactions per second (TPS) and provides liquidity to consumer wallet and B2B partners.",
          "resources": null
        }
      ],
      "philosophy": "To democratize finance by building the bridge between traditional banking and the decentralized future. We believe that financial freedom should be accessible to everyone, everywhere, instantly. Great software is built by empowered teams with a 'You Build It, You Run It' mentality."
    },
    "plan": {
      "title": "Nebula Core Ledger: Concurrent Transaction Engine",
      "description": "A Python-based assessment designed for the Core Ledger Team. This Kata focuses on building a thread-safe financial transaction processor. It assesses the candidate's ability to handle concurrency issues (race conditions), implement structured logging for audit trails, enforce idempotency, and maintain financial data integrity, moving away from Go as per the recent stack migration.",
      "tasks": [
        {
          "id": "domain_modeling",
          "name": "Task 1: Financial Domain Modeling",
          "description": "Define the core entities for the system using Python Data Classes or Pydantic models. We need to represent an `Account` (id, currency, balance) and a `Transaction` (id, source_account, target_account, amount, type, timestamp). Ensure basic validation logic exists (e.g., transactions cannot have negative amounts).",
          "files": [
            "models.py",
            "tests/test_models.py"
          ]
        },
        {
          "id": "basic_ledger_logic",
          "name": "Task 2: The In-Memory Ledger",
          "description": "Implement a `LedgerService` class that handles deposits and withdrawals in memory. The service should update account balances. Implement 'Defensive Programming' principles by raising custom exceptions for insufficient funds or invalid account states.",
          "files": [
            "ledger.py",
            "exceptions.py",
            "tests/test_ledger.py"
          ]
        },
        {
          "id": "concurrency_control",
          "name": "Task 3: Concurrency & Thread Safety",
          "description": "Simulate a high-frequency trading environment where multiple threads attempt to withdraw from the same account simultaneously. Write a failing test that demonstrates a race condition (lost updates). Then, use Python's `threading` and `Lock` (or `RLock`) mechanisms to make the `LedgerService` thread-safe. Ensure operations are atomic.",
          "files": [
            "ledger.py",
            "tests/test_concurrency.py"
          ]
        },
        {
          "id": "structured_logging",
          "name": "Task 4: Audit Logging Module",
          "description": "Financial systems require perfect observability. Implement a custom Logging Module using Python's standard `logging` library. Configure a formatter to output logs in JSON format (structured logging). Every successful transaction and failed attempt must be logged with specific fields: `event_type`, `correlation_id`, `account_id`, `amount`, and `timestamp`. This is critical for the 'You Build It, You Run It' philosophy.",
          "files": [
            "audit_logger.py",
            "utils/json_formatter.py",
            "ledger.py"
          ]
        },
        {
          "id": "idempotency_implementation",
          "name": "Task 5: Distributed Systems Pattern - Idempotency",
          "description": "In a distributed environment (Nebula Wallet -> Core Ledger), network retries are common. Implement an Idempotency mechanism. The `process_transaction` method should accept an `idempotency_key`. If a key has already been processed successfully, return the previous result immediately without re-processing the financial movement.",
          "files": [
            "ledger.py",
            "idempotency_store.py",
            "tests/test_idempotency.py"
          ]
        },
        {
          "id": "money_transfer_saga",
          "name": "Task 6: Atomic Transfers (Saga Pattern Lite)",
          "description": "Implement a `transfer` method to move funds between two accounts. This requires a transaction that spans two distinct updates (debit A, credit B). Ensure that if the credit to B fails, the debit to A is rolled back (simulating atomicity manually or using a context manager to manage the lock scope for both accounts simultaneously to prevent deadlocks).",
          "files": [
            "ledger.py",
            "tests/test_transfer.py"
          ]
        }
      ]
    }
  },
  "e41a2e75-d773-45ee-b716-2941b9529f12": {
    "output_dir": "downloads/e41a2e75-d773-45ee-b716-2941b9529f12",
    "company_info": {
      "roles": [
        {
          "title": "Senior Backend Engineer",
          "stack": [
            "Go",
            "PostgreSQL",
            "DynamoDB",
            "Kubernetes",
            "Docker",
            "AWS",
            "Istio",
            "Linkerd"
          ],
          "requirements": "5+ years of backend engineering experience. Strong proficiency in Go or Java/C++. Deep understanding of distributed systems patterns (idempotency, distributed transactions, SAGAs). Expert knowledge of SQL (PostgreSQL) and NoSQL stores. Solid experience with Kubernetes, Docker, and AWS services. Passion for TDD, clean code, and automated testing.",
          "team": {
            "name": "Core Ledger Team",
            "products": [
              {
                "name": "Ledger v2",
                "type": "product",
                "description": "A new Go-based distributed ledger system designed for scalability and fault tolerance.",
                "resources": []
              },
              {
                "name": "Real-time Transaction Processing System",
                "type": "product",
                "description": "A low-latency system for processing millions of transactions per second.",
                "resources": []
              }
            ],
            "clients": [],
            "size": 5,
            "context": "The heart of Nebula Financial. We manage the systems of record that track every penny (and satoshi) of user funds. We are responsible for the consistency, durability, and availability of the financial ledger.",
            "tools_used": [
              "Node.js",
              "Go",
              "PostgreSQL",
              "DynamoDB",
              "AWS",
              "Kubernetes",
              "Terraform",
              "Datadog",
              "Prometheus",
              "Grafana",
              "SEPA",
              "Swift"
            ],
            "philosophy": [
              "Precision, resilience, and continuous improvement",
              "Ownership & Accountability",
              "Security & Consistency First",
              "Proactive Problem Solving",
              "Knowledge Sharing & Mentorship",
              "Data-Driven Decisions",
              "Test-Driven Development (TDD)",
              "Continuous Integration/Continuous Deployment (CI/CD)",
              "Immutable Infrastructure",
              "Observability",
              "Defensive Programming",
              "You Build It, You Run It"
            ]
          }
        }
      ],
      "teams": [
        {
          "name": "Core Ledger Team",
          "products": [
            {
              "name": "Ledger v2",
              "type": "product",
              "description": "A new Go-based distributed ledger system designed for scalability and fault tolerance.",
              "resources": []
            },
            {
              "name": "Real-time Transaction Processing System",
              "type": "product",
              "description": "A low-latency system for processing millions of transactions per second.",
              "resources": []
            }
          ],
          "clients": [],
          "size": 5,
          "context": "The heart of Nebula Financial. We manage the systems of record that track every penny (and satoshi) of user funds. We are responsible for the consistency, durability, and availability of the financial ledger.",
          "tools_used": [
            "Node.js",
            "Go",
            "PostgreSQL",
            "DynamoDB",
            "AWS",
            "Kubernetes",
            "Terraform",
            "Datadog",
            "Prometheus",
            "Grafana",
            "SEPA",
            "Swift"
          ],
          "philosophy": [
            "Precision, resilience, and continuous improvement",
            "Ownership & Accountability",
            "Security & Consistency First",
            "Proactive Problem Solving",
            "Knowledge Sharing & Mentorship",
            "Data-Driven Decisions",
            "Test-Driven Development (TDD)",
            "Continuous Integration/Continuous Deployment (CI/CD)",
            "Immutable Infrastructure",
            "Observability",
            "Defensive Programming",
            "You Build It, You Run It"
          ]
        }
      ],
      "clients": [],
      "products": [
        {
          "name": "Nebula Wallet",
          "type": "product",
          "description": "Flagship mobile application that allows users to store, send, and swap both fiat and crypto assets with zero fees. Features built-in high-yield savings accounts powered by DeFi protocols.",
          "resources": []
        },
        {
          "name": "Flux Exchange",
          "type": "product",
          "description": "Institutional-grade matching engine for high-frequency trading. Handles over 50,000 transactions per second (TPS).",
          "resources": []
        }
      ],
      "philosophy": "To democratize finance by building the bridge between traditional banking and the decentralized future. We believe that great software is built by empowered teams with a 'You Build It, You Run It' mentality."
    },
    "plan": {
      "title": "Nebula Core Ledger Kata (Python Edition)",
      "description": "Design and implement a highly reliable, double-entry ledger system. This kata focuses on data consistency, concurrency control, and distributed system patterns (idempotency) using Python and PostgreSQL, simulating the constraints of the Core Ledger Team.",
      "tasks": [
        {
          "id": "ledger_schema_design",
          "name": "Double-Entry Schema Implementation",
          "description": "Define the database models for a double-entry bookkeeping system. You need to support 'Accounts' and 'LedgerEntries'. Unlike a simple balance column, the balance must be derivable from the sum of entries. Ensure the schema enforces that the sum of all debits equals the sum of all credits for every transaction group.",
          "files": [
            "models.py",
            "schema.sql",
            "tests/test_schema_integrity.py"
          ]
        },
        {
          "id": "atomic_fund_transfer",
          "name": "Atomic Fund Transfer Service",
          "description": "Implement a service function `move_funds(source_account, destination_account, amount, currency)`. This must create two ledger entries (one debit, one credit) within a single database transaction. If any part of the operation fails, the entire transaction must roll back to ensure money is never created or destroyed.",
          "files": [
            "ledger_service.py",
            "tests/test_atomic_transfer.py"
          ]
        },
        {
          "id": "concurrency_control",
          "name": "Handling Concurrent Movements",
          "description": "Simulate a race condition where multiple threads attempt to withdraw from the same account simultaneously, potentially causing a negative balance despite checks. Implement Pessimistic Locking (SELECT FOR UPDATE) or Optimistic Locking in your Python code/SQL queries to prevent the 'Lost Update' anomaly and ensure non-negative balances.",
          "files": [
            "tests/test_race_conditions.py",
            "db_locking_strategy.py"
          ]
        },
        {
          "id": "idempotency_middleware",
          "name": "Idempotency Implementation",
          "description": "In a distributed system, network timeouts cause clients to retry requests. Implement an idempotency mechanism using an `Idempotency-Key` header. If the same key is sent twice, the system should return the cached response of the first successful operation without re-processing the financial transaction.",
          "files": [
            "middleware.py",
            "idempotency_store.py",
            "tests/test_idempotency.py"
          ]
        },
        {
          "id": "immutable_ledger_corrections",
          "name": "Immutable Corrections (Voiding)",
          "description": "Ledgers are immutable; you cannot delete a row if a mistake is made. Implement a `void_transaction(transaction_id)` feature. This should not delete the original entries but instead create new 'compensating' entries that reverse the amounts, effectively zeroing out the net impact while preserving the audit trail.",
          "files": [
            "reversal_service.py",
            "tests/test_audit_trail.py"
          ]
        },
        {
          "id": "observability_and_metrics",
          "name": "Instrumentation and Observability",
          "description": "The 'You Build It, You Run It' philosophy requires visibility. Decorate your critical transfer functions to emit structured logs and simulate metric collection (e.g., 'ledger.transaction.latency', 'ledger.transaction.failure_count'). Ensure sensitive data (PII or raw account details) is masked in logs.",
          "files": [
            "telemetry.py",
            "logger_config.py"
          ]
        }
      ]
    }
  },
  "84589f0a-e47e-4fcb-968e-2cd5fab3b2a1": {
    "output_dir": "downloads/84589f0a-e47e-4fcb-968e-2cd5fab3b2a1",
    "company_info": {
      "roles": [
        {
          "title": "Senior Backend Engineer (Core Systems)",
          "stack": [
            "Go",
            "PostgreSQL",
            "DynamoDB",
            "Kubernetes",
            "Docker",
            "AWS",
            "Istio",
            "Linkerd"
          ],
          "requirements": "5+ years of backend engineering experience. Strong proficiency in Go or Java/C++. Deep understanding of distributed systems patterns (idempotency, distributed transactions, SAGAs). Expert knowledge of SQL (PostgreSQL) and NoSQL stores. Solid experience with Kubernetes, Docker, and AWS services. Passion for TDD, clean code, and automated testing.",
          "team": {
            "name": "Core Ledger Team",
            "products": [
              {
                "name": "Ledger v2",
                "type": "product",
                "description": "A new Go-based distributed ledger system enhancing scalability and fault tolerance, replacing the legacy Node.js monolith.",
                "resources": null
              },
              {
                "name": "Real-time Transaction Processing System",
                "type": "product",
                "description": "A low-latency system for processing millions of transactions per second, ensuring immediate fund availability.",
                "resources": null
              }
            ],
            "clients": null,
            "size": 5,
            "context": "The heart of Nebula Financial. Manages systems of record that track every penny and satoshi of user funds. Responsible for the consistency, durability, and availability of the financial ledger. Currently migrating from a legacy Node.js monolith to Go microservices.",
            "tools_used": [
              "Go",
              "Node.js",
              "PostgreSQL",
              "DynamoDB",
              "AWS",
              "Kubernetes",
              "EKS",
              "Istio",
              "Terraform",
              "GitHub Actions",
              "Datadog",
              "Prometheus",
              "Grafana"
            ],
            "philosophy": [
              "Precision, resilience, and continuous improvement",
              "Ownership & Accountability",
              "Security & Consistency First",
              "Proactive Problem Solving",
              "Knowledge Sharing & Mentorship",
              "Data-Driven Decisions",
              "Test-Driven Development (TDD)",
              "You Build It, You Run It",
              "Immutable Infrastructure",
              "Defensive Programming"
            ]
          }
        }
      ],
      "teams": [
        {
          "name": "Core Ledger Team",
          "products": [
            {
              "name": "Ledger v2",
              "type": "product",
              "description": "A new Go-based distributed ledger system enhancing scalability and fault tolerance.",
              "resources": null
            },
            {
              "name": "Real-time Transaction Processing System",
              "type": "product",
              "description": "Low-latency system for processing millions of transactions per second.",
              "resources": null
            }
          ],
          "clients": null,
          "size": 5,
          "context": "The Core Ledger Team is the heart of Nebula Financial, managing systems of record for user funds and ensuring consistency, durability, and availability of the financial ledger.",
          "tools_used": [
            "Go",
            "Node.js",
            "PostgreSQL",
            "DynamoDB",
            "AWS",
            "Kubernetes",
            "Terraform",
            "Datadog",
            "Prometheus",
            "Grafana"
          ],
          "philosophy": [
            "Precision, resilience, and continuous improvement",
            "Ownership & Accountability",
            "Security & Consistency First",
            "Proactive Problem Solving",
            "Knowledge Sharing & Mentorship",
            "Data-Driven Decisions",
            "Test-Driven Development (TDD)",
            "Immutable Infrastructure",
            "Observability",
            "Defensive Programming",
            "You Build It, You Run It"
          ]
        }
      ],
      "clients": null,
      "products": [
        {
          "name": "Nebula Wallet",
          "type": "product",
          "description": "Flagship mobile application that allows users to store, send, and swap both fiat and crypto assets with zero fees. Features built-in high-yield savings accounts powered by DeFi protocols.",
          "resources": null
        },
        {
          "name": "Flux Exchange",
          "type": "product",
          "description": "Institutional-grade matching engine for high-frequency trading. Handles over 50,000 transactions per second (TPS) and provides liquidity to the consumer wallet and B2B partners.",
          "resources": null
        }
      ],
      "philosophy": "To democratize finance by building the bridge between traditional banking and the decentralized future. We believe that great software is built by empowered teams with a 'You Build It, You Run It' mentality, prioritizing trust, security, and velocity with precision."
    },
    "plan": {
      "title": "Distributed Ledger Transaction Processor Kata",
      "description": "This coding kata assesses a candidate's suitability for a Senior Backend Engineer role on the Core Ledger Team at Nebula Financial. It simulates building a critical, high-performance component of the Real-time Transaction Processing System. Candidates will demonstrate proficiency in Go, distributed systems patterns (idempotency, SAGA), PostgreSQL interactions, robust error handling, TDD, and observability, reflecting the team's philosophy of precision, resilience, and security.",
      "tasks": [
        {
          "id": "define_transaction_models",
          "name": "Transaction Data Models and Idempotency Key Definition",
          "description": "Design Go structs to represent core financial entities like `Transaction` and a simplified `AccountBalance`. The `Transaction` struct must include fields such as `ID`, `SourceAccountID`, `DestinationAccountID`, `Amount`, `Currency`, `Status` (e.g., Pending, Completed, Failed), `Timestamp`, and `IdempotencyKey`. Implement a deterministic function to generate a unique `IdempotencyKey` based on relevant transaction parameters, suitable for preventing duplicate processing in a distributed environment.",
          "files": [
            "transaction/model.go",
            "transaction/model_test.go"
          ]
        },
        {
          "id": "persist_transaction",
          "name": "Transaction Persistence Layer with PostgreSQL",
          "description": "Implement a data access layer (repository) in Go for storing and retrieving `Transaction` objects using PostgreSQL. This involves defining a basic SQL schema for the `transactions` table. Implement `SaveTransaction(ctx context.Context, tx Transaction) error` and `GetTransactionByID(ctx context.Context, id string) (Transaction, error)` methods, focusing on ensuring atomicity for write operations and proper error handling. Adhere to Test-Driven Development (TDD) principles.",
          "files": [
            "db/migrations/001_create_transactions_table.up.sql",
            "db/transaction_repository.go",
            "db/transaction_repository_test.go"
          ]
        },
        {
          "id": "idempotent_processing_core",
          "name": "Idempotent Transaction Processing Logic",
          "description": "Develop the core business logic for processing a financial transaction. This logic must incorporate an idempotency check: before processing, query the database to see if a transaction with the given `IdempotencyKey` has already been successfully processed. If so, return the existing result. Otherwise, proceed to deduct from the source account, credit the destination account (simulating with a simple `AccountService` interface), and then persist the `Transaction` with its final status. Pay attention to concurrent safety for idempotency and defensive programming practices.",
          "files": [
            "service/transaction_processor.go",
            "service/transaction_processor_test.go",
            "mocks/mock_account_service.go"
          ]
        },
        {
          "id": "distributed_transaction_saga",
          "name": "Simulated Distributed Transaction with Compensation (Simplified Saga)",
          "description": "Extend the transaction processing logic to simulate a simplified distributed transaction involving multiple steps (e.g., `DebitSourceAccount`, `CreditDestinationAccount`). Implement a mechanism to handle failures at any intermediate step, requiring a compensation or rollback logic (e.g., if crediting fails, the previous debit needs to be reversed). This can be achieved by introducing a `SagaManager` or an orchestrator pattern that manages the state transitions and compensation actions. Focus on robust error handling and defining clear transaction states.",
          "files": [
            "service/saga_orchestrator.go",
            "service/saga_orchestrator_test.go",
            "mocks/mock_compensation_service.go"
          ]
        },
        {
          "id": "add_observability_resilience",
          "name": "Add Observability and Basic Resilience Patterns",
          "description": "Enhance the transaction processing service with production-grade observability and resilience. Integrate Prometheus-style metrics (e.g., transaction processing duration, count of successful/failed transactions, idempotency hit ratio). Add structured logging for key events and errors. Additionally, introduce a basic resilience pattern, such as a simple retry mechanism with exponential backoff for an external dependency (e.g., the `AccountService` or compensation service, represented by an interface). This demonstrates an understanding of operational readiness for critical systems.",
          "files": [
            "metrics/collector.go",
            "logging/logger.go",
            "service/transaction_processor_resilient.go",
            "service/transaction_processor_resilient_test.go"
          ]
        }
      ]
    }
  }
}